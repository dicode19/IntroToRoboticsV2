Дотримання лінії: пропорційне керування з обома датчиками
==========================================================

Слідування лінії з пропорційним керуванням за допомогою одного датчика є значним
поліпшенням порівняно з керуванням типу «увімкнено/вимкнено». 
Однак це не ідеальний варіант — якщо датчик відбиття перетинає центр лінії, гра закінчується.

.. figure:: media/p_control_2_sensors_actions.png
    :align: center

    Бажані дії рульового управління на основі того, що бачить датчик.

Проблема в тому, що робот не має можливості дізнатися, по якій стороні лінії він рухається!
Якщо він бачить правий край лінії, він буде вважати, що все ще
виявляє лівий край, і тому продовжуватиме повертати праворуч, проїжджаючи точку неповернення!

Було б чудово, якби ми могли фактично слідувати за центром лінії і
розпізнавати обидва випадки, коли робот відхиляється вліво або вправо від
центру лінії, і вносити корективи. Це значно збільшило б
«контрольований» діапазон того, що бачить датчик відбиття і на що може правильно реагувати.
Зручно, що, схоже, ми ще не використовували другий датчик відбиття праворуч. .

Якщо ми записували відбиття обох датчиків під час переміщення робота по лінії,
то можна виділити кілька основних «категорій» поведінки, які виконував би робот.
На хвилинку уявімо, що прямокутник — це чорна лінія, а два червоні квадрати —
місце розташування датчиків відбиття.

.. figure:: media/p_control_2_sensors_left.png
    :align: center

    Спрощений вигляд обох датчиків відбиття, повністю відключених від лінії.

Датчики показують ~0 і ~0. Робот не знає, чи знаходиться він зліва чи справа
від лінії.

.. figure:: media/p_control_2_sensors_half.png
    :align: center

    Спрощений вигляд обох датчиків відбиття, розташованих наполовину на лінії.

Датчики зчитують ~0 і ~1. Робот розуміє, що знаходиться зліва, і повертає праворуч.

.. figure:: media/p_control_2_sensors_centered.png
    :align: center

    Спрощений вигляд обох датчиків відбиття, розташованих по центру лінії.

Датчики показують ~0,5 і ~0,5. Робот розуміє, що знаходиться в центрі, і рухається прямо.

Дві інші основні категорії ви можете експортувати самостійно.

Отже, як ми можемо ефективно поєднати показання лівого та правого
датчиків відбиття за допомогою пропорційного регулювання, щоб робот слідував за
лінією? Існує досить елегантне рішення, яке я рекомендую вам спробувати
вирішити самостійно, перш ніж буде розкрито відповідь.

Впровадження
--------------
.. tab-set::

    .. tab-item:: Python

        .. code-block:: python

            error = reflectance.get_left() - reflectance.get_right()

    .. tab-item:: Blockly

        .. image:: media/error.png
            :width: 300

Спочатку цей рядок коду може здатися не дуже зрозумілим, але давайте
розберемо його. Згадайте нашу попередню угоду про те, що позитивна помилка означає, що робот
знаходиться занадто далеко ліворуч і повинен повернути праворуч, і навпаки.

У цьому випадку, якщо робот рухається вздовж лівого краю лінії, то лівий
датчик фіксує колір, близький до білого, а правий датчик фіксує колір, близький до чорного, 
і отже:

.. math:: 

    \begin{align}
    \text{error} & = 0 - 1 \\
    & = -1
    \end{align}


Це змушує робота повернути праворуч. З іншого боку, якщо
робот рухається вздовж правого краю лінії:

.. math:: 

    \begin{align}
    \text{error} & = 1 - 0 \\
    & = 1
    \end{align}

Це змушує робота повернути ліворуч. Коли робот знаходиться точно в центрі, обидва
значення датчиків однакові, тому похибка дорівнює 0, а коли робот починає
відхилятися в будь-якому напрямку, величина похибки збільшується, і
робот відповідно компенсує її.

Найцікавіший випадок - це коли робот повністю з'їжджає з лінії - в цьому
випадку обидва датчики показують білий колір, залишаючи похибку 0, і робот просто рухається
прямо. З огляду на те, що робот не знає, в якому напрямку компенсувати, якщо він
повністю з'їхав з лінії, це здається розумним результатом.

Отже, наш остаточний код виглядає наступним чином:

.. tab-set::

    .. tab-item:: Python

        .. code-block:: python

            from XRPLib.defaults import *

            # Try different values for KP and base_effort to get things working smoothly
            KP = 1
            base_effort = 0.5

            while True:
                error = reflectance.get_left() - reflectance.get_right()
                drivetrain.set_effort(base_effort - KP * error, base_effort + KP * error)
    
    .. tab-item:: Blockly
        
        .. image:: media/set_effort_program.png
            :width: 550

Ось як це виглядає. Зверніть увагу, що KP, використаний у цьому відео, не дорівнював 1:

.. error:: 
    
    TODO add video


.. admonition:: Спробуйте

    * Поєднайте отримані знання з енкодерами, щоб створити функцію, яка       
      слідує за лінією, використовуючи два датчики на певній відстані, а потім зупиняє      
      двигуни.
    * Яке значення KP є найкращим? 
    * Порівняйте один датчик з двома датчиками, що слідують за лінією. Що згинається в чорній      
      лінії, що два датчики, які слідують за лінією, здатні впоратися з тим, з чим не може впоратися        один датчик, що слідує за лінією?
