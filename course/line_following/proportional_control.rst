Слідування за лінією: пропорційне керування
========================================

У модулі вимірювання відстаней ви використовували пропорційне керування, щоб
робот рухався прямо вздовж стіни. Ми можемо застосувати пропорційне керування і до завдання
слідування за лінією!


Переваги пропорційного керування
---------------------------------

Повернемося до попереднього завдання — слідування лінії шляхом
повороту вліво або вправо залежно від того, чи знаходиться робот ліворуч чи
праворуч від лінії.

Що відразу впадає в око при такому слідуванні за лінією? Ну,
робот повинен постійно коливатися, щоб залишатися на краю лінії,
тому що навіть найменше відхилення від краю лінії призводить до того, що
робот різко повертає, щоб компенсувати це. Крім того, він не реагує більш
рішуче на більші відхилення, наприклад, коли лінія починає вигинатися, і як тільки
він втрачає лінію з поля зору, він не має можливості відновитися.

Замість двох випадків, здається, нам потрібно ціла низка
випадків, від різкого повороту вліво до руху по прямій до
різкого повороту вправо, і все, що між ними, залежно від того, чи датчик відбиття
повністю на білому, сірому, чорному або десь посередині.

.. figure:: media/p_control_1.png
    :align: center

    Бажані дії рульового управління на основі того, що бачить датчик.

Наявність довгого ланцюжка операторів if-else не здається приємною справою. Можливо, ми можемо поглянути
на це з абсолютно нового боку?

У попередньому модулі ми розглядали пропорційне регулювання для плавного контролю
відстані робота до стіни за допомогою датчика відстані. Чи можемо ми використовувати ту саму
концепцію тут?

Розрахунок помилки
-----------------

При пропорційному регулюванні ми маємо значення похибки, яке ми хочемо звести до
нуля, і частина вихідної потужності двигуна регулюється пропорційно похибці, щоб мінімізувати
цю похибку - у випадку підтримки певної відстані до стіни,
похибка була різницею між цільовою і фактичною відстанню, а вихідною потужністю
була швидкість обох приводних двигунів. У випадку слідування лінії похибка є
різницею від 0,5 — оскільки в ідеалі робот слідує за сірим краєм
лінії і рухається прямо — а вихідна потужність двигуна визначає, як робот повинен повертати.


Отже, ми можемо отримати значення похибки за допомогою наступного коду:

.. tab-set::

    .. tab-item:: Python

        .. code-block:: python

            error = reflectance.get_left() - 0.5

    .. tab-item:: Blockly

        .. image:: media/set_error.png
            :width: 300

Вище ми віднімаємо 0,5, щоб *нормалізувати* значення відбиття: помилка є
негативною, коли робот знаходиться занадто далеко ліворуч і повинен повернути праворуч, і позитивною,
коли робот знаходиться занадто далеко праворуч і повинен повернути ліворуч. Давайте перевіримо цей код на
практиці. Ми можемо помістити його в цикл, виводити помилку при кожній ітерації і
переміщати робота по лінії, щоб побачити, як змінюється помилка. Код виглядає
наступним чином:

.. tab-set::

    .. tab-item:: Python

        .. code-block:: python

            from XRPLib.defaults import *
            from time import sleep

            while True:
                error = reflectance.get_left() - 0.5
                print("Error: ", error)
                sleep(0.1) # Цей сон змушує цикл виконуватися 10 разів на секунду

    .. tab-item:: Blockly

        .. image:: media/print_error.png
            :width: 300

Впровадження пропорційного управління
---------------------------------

На основі обчисленої похибки ми хочемо визначити, на скільки повинен повернутись робот. 

.. figure:: media/p_control_2.png
    :align: center

    Бажані дії керування та пропорційний вихідний сигнал управління на основі того, що
    бачить датчик.

Це зображення ілюструє, як похибка впливає на те, наскільки ми хочемо повернути. Пам'ятайте:
повернути робота означає просто встановити різні зусилля для лівого і правого двигунів.
 Отже, рішення полягає в тому, щоб встановити базове зусилля, скажімо, 50%, з яким обидва
двигуни рухаються, коли похибка дорівнює 0. Потім розрахована похибка впливає на
різницю в зусиллях між двома двигунами. Як пояснено в коді:

.. tab-set::

    .. tab-item:: Python

        .. code-block:: python

            drivetrain.set_effort(base_effort - KP * error, base_effort + KP * error)

    .. tab-item:: Blockly
        
        .. image:: media/set_effort_error.png
            :width: 300

Це буде виконуватися всередині циклу. base_effort представляє середнє зусилля двигунів, незалежно від того, наскільки повертається робот. KP масштабує, наскільки робот повинен повертатися, виходячи з похибки - більш високе значення KP означає, що робот буде реагувати більш
різко на невеликі відхилення в похибці.

Давайте швидко перевіримо, чи має сенс цей код. Припустимо, що base_effort
= 0,5 і KP = 1. Якщо відбиття має біло-сірий колір і дає значення
близько 0,25, помилка буде -0,25, що означає, що зусилля лівого двигуна становить:

.. math:: 

    0.5 - 1 \cdot -0.25 \\
    \begin{align}
    & = 0.5 + 0.25 \\
    & = 0.75
    \end{align}

а швидкість правого двигуна становить: 

.. math:: 

    0.5 + 1 \cdot -0.25 \\
    \begin{align}
    & = 0.5 - 0.25 \\
    & = 0.25
    \end{align}

Моторні зусилля 0,75 і 0,25 вказують на поворот вправо, і код працює як потрібно.

Це відео ілюструє слідування лінії за допомогою управління одним датчиком. Зверніть увагу на
більш плавне відстеження в порівнянні з управлінням увімкнення/вимкнення, проте робот все ще не може відновити рівновагу після останнього повороту, оскільки навіть невелике відхилення від
лінії призводить до того, що робот повністю втрачає орієнтацію. Крім того, значення KP тут
не дорівнювало 1; вам належить самостійно визначити найкраще значення KP для вашого
бота.


.. figure:: media/proportional_line_following.gif
    :align: center

    XRP слідує лінії з пропорційним керуванням. Робот не зміг би 
    так швидко слідувати кривій лінії, використовуючи імпульсне керування!

.. admonition:: Спробуйте це
    
    Напишіть код для робота, щоб він слідував за лінією з пропорційним керуванням, як
    показано у відео вище. Примітка: це не набагато більше, ніж обчислення похибки,
    як показано в попередньому розділі, а потім інтегрування вищезазначеного рядка коду в 
    цикл.

    Поекспериментуйте зі значенням KP. Як вищий або нижчий KP впливає на
    величину коливань під час слідування за лінією та на чутливість робота
    до кривих ліній? Яке оптимальне значення KP?
