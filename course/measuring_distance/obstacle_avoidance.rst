Уникнення перешкод 
==================

Одним із корисних застосувань ультразвукового датчика є уникнення перешкод. 

У цьому підручнику ми навчимося використовувати ультразвуковий датчик, щоб спочатку зупинитися на певній відстані від об'єкта, а потім уникнути зіткнення з об'єктом, повертаючись під випадковим кутом від нього. 

Крок 1: Просунутися на певну відстань
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Першим кроком уникнення перешкод є зупинка на певній відстані від об'єкта.
Для цього ми хочемо постійно зчитувати відстань датчика відстані та перевіряти, чи вона менша,
скажімо, 10 см. Як тільки вона перевищує цей поріг, ми хочемо зупинити робота.

Для цього ми можемо використовувати цикл while з умовою, яка перевіряє, чи
відстань датчика менша за 10 см.

.. tab-set::

    .. tab-item:: Python

        .. code-block:: python

            drivetrain.set_speed(10, 10)
            while rangefinder.distance() > 10:
                time.sleep(0.1)
            drivetrain.stop()


    .. tab-item:: Blockly

        .. image:: media/forwarduntildistance.png
            :width: 300

Крок 2: Поворот на 180 градусів після виявлення об'єкта
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Замість того, щоб просто зупинитися, ми хочемо розвернутися на 180 градусів, рухатися вперед і повторювати це, розвертаючись на 180 градусів щоразу, коли виявляємо об'єкт.

Щоб повернути на 180 градусів, нам потрібно замінити :code:`drivetrain.stop()` на :code:`drivetrain.turn(180)`. Після цього нам потрібно знову рухатися вперед. Але замість того, щоб знову писати :code:`drivetrain.set_speed(10, 10)`, зверніть увагу, що ми просто намагаємося виконувати ці два кроки знову і знову:
    1. Рухатися вперед, поки не буде виявлено об'єкт
    2. Повернути на 180 градусів

Схоже, ми можемо об'єднати ці два кроки в циклі while! Ось як виглядає код:

.. tab-set::

    .. tab-item:: Python

        .. code-block:: python

            # Repeat these two steps over and over again
            while True:

                # Go forward until an object is detected
                drivetrain.set_speed(10, 10)
                while rangefinder.distance() > 10:
                    time.sleep(0.1)

                # Turn 180 degrees
                drivetrain.turn(180)


    .. tab-item:: Blockly

        .. image:: media/forwardturnrepeat.png
            :width: 300

Крок 3: Поворот під випадковим кутом після виявлення об'єкта
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Незважаючи на те, що ми повертаємося після виявлення об'єкта, ви повинні помітити, що ваш робот застрягає в циклі. Оскільки робот повертається на 180 градусів, він часто повертається до об'єкта, який щойно виявив. Щоб виправити це, багато роботів, таких як iRobot's Roomba, використовують простий алгоритм, відомий як «bump and run» (зіткнись і біжи). Якщо ви зіткнулися з об'єктом, замість того, щоб повертатися на 180 градусів, робот повинен відвернутися від нього під випадковим кутом, щоб збільшити шанс, що він досліджуватиме нову територію.

Однак, якщо робот повернеться під абсолютно випадковим кутом, існує ймовірність, що він майже не повернеться, якщо випадкове число буде невеликим. Тому ми хочемо надати роботу розумний діапазон випадкових кутів, з яких він може вибирати.

.. tab-set::

    .. tab-item:: Python

        Ми можемо використовувати :code:`random.randint(135, 225)` для генерації випадкового числа            від 135 до 225, яке ми можемо перетворити на відповідну кількість градусів.        
        Однак зверніть увагу, що нам потрібно :code:`import random` у верхній частині програми, щоб           імпортувати бібліотеку, яка містить цю функцію.

        .. code-block:: python

            # the library that contains random.randint
            import random

            # Repeat these two steps over and over again
            while True:

                # Go forward until an object is detected
                drivetrain.set_speed(10, 10)
                while rangefinder.distance() > 10:
                    time.sleep(0.1)

                # Turn random amount between 135 and 225 degrees
                turnDegrees = random.randint(135, 225)
                drivetrain.turn(turnDegrees)


    .. tab-item:: Blockly

        Blockly provides a handy block for generating a random number between lower and upper bounds, inclusive.

        .. image:: media/forwardturnrepeatrandom.png
            :width: 400


І ось! Ми успішно створили програму, за допомогою якої наш робот може назавжди уникати перешкод!
