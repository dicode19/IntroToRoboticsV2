Вступ до слідування за стіною
==============================

Тепер, коли ви розробили програму для збереження певної відстані від об'єкта, давайте реалізуємо це, змусивши XRP слідувати за стіною, підтримуючи цільову відстань.

Створення закону управління
----------------------

Коли ви рухаєтеся вздовж стіни, все, що вам потрібно зробити, це керувати роботом так, щоб підтримувати певну відстань від стіни. Якщо ви рухаєтеся вздовж стіни праворуч від себе, ви повернете праворуч, якщо відстань занадто велика, і ліворуч, якщо відстань занадто мала. Це легко зробити за допомогою пропорційного контуру регулювання. Корекція керування може бути пропорційною похибці, у цьому випадку різниці між відстанню до стіни та цільовою відстанню до стіни.
 
.. tip::
   Пам'ятайте, що вам потрібно буде додати «базове зусилля», щоб робот постійно рухався вперед.        Встановимо його значення на **0,5**.

   Також важливо зазначити, що сторона, яку ви оберете для розміщення ультразвукового далекоміра, вплине на реалізацію закону управління. 

Тепер реалізуйте пропорційний контролер, враховуючи кроки, які ви виконали раніше, та поради, зазначені вище. 

Перегляньте це відео, щоб побачити, як виглядає робочий пристрій для стеження за стіною. 

 .. image:: media/wallfollowing.gif


Реалізація функції «Слідування за стіною»
-----------------------------------------

Сьогодні давайте використаємо інформацію, яку ми дізналися минулого разу, щоб фактично реалізувати слідування за стіною. 

Ось код, який дозволить вашому XRP відстежувати стіну з правого боку робота. 

.. tab-set::

    .. tab-item:: Python

        .. code-block:: python

            from XRPLib.differential_drive import DifferentialDrive
            from XRPLib.rangefinder import Rangefinder

            kP = None
            targetDist = None

            differentialDrive = DifferentialDrive.get_default_differential_drive()

            rangefinder = Rangefinder.get_default_rangefinder()


            kP = 0.02
            targetDist = 20
            while True:
                differentialDrive.set_effort((0.4 + kP * ((rangefinder.distance()) - targetDist)), (0.4 + (kP * ((rangefinder.distance()) - targetDist)) * -1))


    .. tab-item:: Blockly

        .. image:: media/wall-follow-blockly.png
            :width: 600
